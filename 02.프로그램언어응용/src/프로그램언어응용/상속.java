package 프로그램언어응용;

public class 상속 {
	/* 2022-02-08
	 * 
	 * [상속]
	 * 
	 * 객체지향 언어의 장점은 유지 보수성이 높은 시스템을 개발할 수 있다는 것이다.
	 * 유지보수성을 높이는 가장 기본적인 원칙은 "중복을 제거 하는 것"이다
	 * sp
	 * 직원, 강사, 학생의 정보를 프로그램으로 만든다면
	 * 
	 * person
	 * (이름, 나이)
	 * ↓
	 * ↓상속한다
	 * ↓
	 * 1, 직원
	 * 2, 강사
	 * 3, 학생
	 * 
	 * 상속이란 ?
	 * 기존에 존재하는 유사한 클래스로부터 속성가 동작을 그대로 가져다 사용하면서 자신이 필요한 기능을 추가하는 것
	 * 
	 * 1, 이미 존재하는 클래스 (상속하는 클래스, 내용이 정의된 클래스) -> 슈퍼 클래스, 부모 클래스
	 * 2, 상속받는 클래스 (가져다 사용하는 클래스) -> 서브 클래스, 자식 클래스
	 * 필요하다
	 * 
	 * 상속의 효과
	 * 1, 부모 클래스를 재사용해서 자식 클래스 빨리 개발 가능
	 * 2, 반복된 코드 중복 줄임
	 * 3, 유지보수 편리성 제공
	 * 3, 객체 다형성 구현 가능
	 * 
	 * 상속 대상의 제한
	 * 1, 부모 클래스의 private 필드와 메소드 제외
	 * 2, 부모 클래스가 다른 패키지에 있을 경우, default 필드와 메서드 제외
	 * 
	 * [extends] 키워드
	 * : 자식 클래스가 상속할 부모 클래스를 지정하는 키워드
	 * 
	 * [클래스 상속 방법]
	 * 접근제한자 class 자식클래스명 extends 부모클래스명 {
	 * }
	 * 
	 * ex) class Student extends Person {
	 *  	// 추가된 필드와 메소드 정의
	 *  }
	 * Person클래스를 확장하여 서브클래스를 작성하겠습니다. 라는 뜻
	 *
	 * 자바는 단일 상속 
	 * - 여러 부모클래스 X
	 * - 한 개의 부모 클래스, 여러 개의 자식 클래스
	 * 
	 * class Person {...}   // 부모 클래스
	 * class Employee extends Person {...}	// 자식 클래스 1
	 * class Professor extends Person {...} // 자식 클래스 2
	 * class Student extends Person {...}	// 자식 클래스 3
	 * 
	 * 예제 class Employee 참고
	 * 예제 exam_inheritance 패키지 참고
	 * 
	 * 
	 * Employee e = new Employee();
	 * Professor p = new Professor();
	 * Student s = new Student();
	 * 
	 * 스택영역
	 * main e   &주솟값
	 * 		p	&주솟값
	 * 		s	&주솟값
	 * 
	 * 힙영역
	 * 
	 *   -Employee-				   -Professor-			-Student-
	 * 
	 * (---------------부모클래스에게 상속받은 부분(공통적으로 사용하는 부분)--------------------)
	 * name null				name null 				name null
	 * age 0					age 0 					age 0
	 * setName  &주솟값			setName &주솟값			setName &주솟값
	 * getName  &주솟값			getName &주솟값 			getName &주솟값
	 * setAge   &주솟값			setAge  &주솟값			setAge  &주솟값
	 * getAge   &주솟값			getAge  &주솟값			getAge  &주솟값
	 * 
	 * (Employee에서 새로 생성한 부분)  (professor '')		(Student '')
	 * dept  	null			subject null			major null
	 * setDept  &주솟값			setSubject &주솟값		setMajor &주솟값
	 * getDept	&주솟값			getSubject &주솟값		setMajor &주솟값
	 * 
	 * UML표기법 (화살표 방향으로 구분)
	 * Super Class <-  Sub Class
	 * (부모 클래스 ) <- (자식 클래스) 
	 * 
	 * 상속의 예
	 * Animal(동물)   <- Dog(개), Cat(고양이)
	 * Vehicle(탈 것)	 <-  Car, Bus, Boat, cycle
	 * 
	 * 상속의 계층 구조
	 * 상속 관계는 일반적으로 트리 모양의 계층 구조를 형성한다
	 * 	ex)    Vehicle
	 * 	(SpeedUp(), SpeedDown())
	 *    ↗       ↑		   ↖	
	 * Car		Truck 		Bus
	 *  ↑
	 * SportsCar
	 * 
	 * 슈퍼 클래스를 변경하면 서브 클래스에 영향을 준다
	 * 하지만 서브 클래스가 변경돼도 슈퍼 클래스는 영향이 없다.
	 * 
	 * 상속은 is-a 관계
	 * 서브 클래스와 수퍼 클래스는 "~은 ~이다"의 is-a 관계
	 * 상속의 구조가 올바른지 확인하려면 is-a관계가 성립하는지 생각해봐야한다.
	 * 
	 * ex)
	 * 자동자는 탈 것이다. (Car is a Verhicle)
	 * 무선 전화기는 전화기이다.
	 * 사자, 개, 고양이는 동물이다.
	 * 노트북은 컴퓨터이다.
	 * 원은 도형이다.
	 * 
	 * 만약 has-a 관계 (~는 ~을 가지고 있다.)라면
	 * 이 관계는 상속으로 모델링하면 안 된다.
	 * 도서관은 책을 갖고 있다. (Library has a book)
	 * 거실은 소파를 갖고 있다.
	 * 
	 * 이런 경우에는 하나의 클래스 안에 다른 클래스 객체를 포함시켜야 한다.
	 * class Point {					class Line{
	 * 		private int x;		→			private Point p1;  (Point라는 클래스를 포함하게 됨)
	 * 		private int y;					private Point p2;
	 * }								}
	 * class Line은 이걸 표현하려고 하는 것 (Line은 두 점을 갖고 있다)
	 *    ·──────────────────────·
	 * (x, y)                 (x1, y1)
	 * 
	 * 
	 * [super] 참조변수
	 * 객체 자신을 참조하는 참조변수인 this처럼 모든 하위 클래스의 객체에는 상위 클래스를 참조하는 참조변수 super가 있다.
	 * 
	 * this : 현재 실행중인 인스턴스의 주솟값
	 * this.필드명 = 매개변수;
	 * this() - 생성자가 다른 생성자를 호출할 때 사용
	 * 
	 * super : 부모 클래스의 주솟값
	 * super.필드명;   - 상위 클래스의 클래스 변수나 접근 제어에 의해 접근이 가능한 필드에 접근한다.
	 * super.메서드(); - 상위 클래스의 메서드에 접근한다
	 * super();      - 상위 클래스의 생성자에 접근한다.
	 * 
	 * [메소드 재정의(오버라이딩)]
	 * 상속받은 자식 클래스에서 부모 클래스에 정의된 메소드를 재정의하는 것
	 * 이미 정의된 메서드를 재정의 하는 기술이다.
	 * ☆부모 클래스의 메소드와 동일한 시그니처를 가져야한다★
	 * 메서드의 선언(시그니처) : 접근제한자 반환형 메서드명 (매개변수) {
	 * 							메소드의 정의
	 * 						}
	 * (메소드의 이름, 반환형, 매개 변수의 개수와 데이터 타입이 일치하여야한다)
	 * 슈퍼클래스의 메소드가 public으로 선언되어 있어야한다. private메소드는 재정의 할 수 없다.
	 * 
	 * 
	 * - 부모 클래스 -
	 * public String toString() {   	// 문자열 toString
	 *	return name + " : " + age;
	 * 
	 * ↓ 부모 클래스의 메소드를 재정의 ↓
	 * 
	 * - 자식 클래스 - 
	 * public String toString() {
	 *	return super.toString() + " : " + major;
     * }
	 * 
	 * 오버라이딩 조건
	 * 1. 상속한 메서드의 본문만 변경할 수 있다.
	 * 2. 상속한 메서드의 선언부를 변경할 수 없다. (선언부가 바뀌면 그냥 새로 만든거임)
	 * 3. 접근 제한자는 부모의 메서드와 같거나 넓은 범위로만 변경할 수 있다.
	 * 	 - public을 default나 private으로 수정 불가
	 * 	 - default를 public으로 수정 가능
	 * 4. 프로그램 실행시 메서드 호출 순위는 오버라이딩한 메서드가 부모 클래스의 메서드보다 높다.
	 * 
	 * [어노테이션(Annotation)]
	 * 프로그램에게 추가적인 정보를 제공해주는 메타데이터이다
	 * 메타데이터란 ? 데이터에 관한 
	 * 
	 * 컴파일러에게 코드 작성 문법 에러 체크하도록 정보를 제공
	 * 
	 * 만약에 sound()를 오타내서 saund()라고 하면 컴퓨터는 다른 것으로 인식하기 때문에 오버라이딩 되지 않으며
	 * 컴파일러는 saund()를 새로운 메소드로 인지하고 오류가 발생하지 않는다
	 * 
	 * @Override 어노테이션
	 * 컴파일러에게 부모 클래스의 메소드 선언부와 동일한지 검사 지시
	 * 
	 * @Override 사용법
	 * class Dog extends Animal {
	 * 		@Override
	 * 		public void saund(){
	 * 			sysout("멍멍!");
	 * }}
	 * 
	 * 부모 생성자 호출(super(...))
	 * 자식 객체를 생성하면 부모 객체도 생성되나요??
	 * 부모 없는 자식은 없다
	 *  - 자식 객체 에ㅔ//./ㅋㅊ추가!
	 *  
	 * new 서브 클래스 객체가 생성될 때 
	 *  - 슈퍼클래스 생성자와 서브 클래스 생성자 모두 실행된다
	 *  - 호출 순서
	 *  	서브 클래스의 생성자가 먼저 호출, 서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출
	 *  - 실행 순서
	 *  	슈퍼 클래스의 생성자가 ---먼저 실행---> 서브 클래스의 생성자 실행
	 * 
	 * 
	 * [매개변수를 갖고 있는 부모 생성자 호출]
	 * 
	 * (1) 명시적인 부모 생성자 호출
	 * -부모 객체 생성할 때 부모 생성자 선택해 호출
	 * 
	 *  자식 클래스(매개변수, 매개변수...){
	 *  	super (매개변수, 매개면수);  // 매개변수가 없을 때는 super();가 생략되어 있는 것
	 *  	...
	 *  }
	 *  
	 *  super(매개값...)
	 *  - 매개값과 동일한 타입, 개수, 순서에 맞는 부모 생성자 호출
	 *  반드시 자식 생성자의 첫 줄에 위치
	 *  부모 클래스에 기본(매개변수 없는) 생성자가 없다면 필수로 작성
	 *
	 * (2) 묵시적인 호출
	 * 수퍼 클래스의 생성자를 명시하지 않아도 자동으로 호출됨
	 * 
	 * 
	 * 상속과 생성자 (정리)
	 * 1, 생성자는 상속되지 않는다.
	 * 2, 하위 클래스의 생성자를 호출하면 상위클래스로부터 상속받은 멤버의 생성과 초기화가 먼저 이루어지도록 상위생성자를 호출한다
	 * 이때 호출되는 상위 클래스 생성자는 기본 생성자이다 super()
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 * 
	 */
	
	
}
